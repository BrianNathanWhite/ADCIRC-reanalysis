---
title: "two-stage-inference-alternate"
author: "Brian N. White"
date: "2022-05-11"
output: html_document
---

```{r, set global code chunk options, include = F}
knitr::opts_chunk$set(fig.align = 'center', warning = F, message = F, tidy = TRUE) # centers figures generated by code chunks
```

```{r load packages}
library(tidyverse) # data manipulation meta-package
library(reshape2) # for combining multiple variables into single column
library(pheatmap) # genreate heatmaps
library(naniar) # for replacing value with NA 
library(flextable) # for pretty table creation
library(kableExtra) # for pretty table creation; adds onto the kable table from knitr
library(magick) # for kable export to png
library(RColorBrewer) # adds color palattees for plotly
library(Matrix) # for use in computing Kronecker product
library(matrixcalc) # for use in computing Hadamaard product
library(blockmatrix) # compute block matrices
library(mvtnorm) # compute MVN density
library(extRemes) # compute MLE of GEV model
library(geosphere) # used to compute geodesic distance between lat-lon pairs
library(plotly) # for 3D plotting
library(gganimate) # for creating animations out of ggplot objects
library(maps) # contains US maps
library(ggmap) # for manipulating map objects via ggplot
library(svMisc) # allows you to track for loop progress
```

```{r import data}
# data covers FEMA region 3
df_meta_region3 <- read.csv('data/df_meta_region3.csv') # lat-lon data
ADC_POST_Detided_region3 <- read.csv('data/ADC_POST_Detided_region3.csv') #  modeled (ADCIRC) data
NOAA_OBS_Detided_region3 <- read.csv('data/NOAA_OBS_Detided_region3.csv') # observed (NOAA) data
```

```{r clean data}
source('./functions/clean_timeseries.R') # converts time to POSIX class, adds variables month & year, replace station ID with station name
source('./functions/clean_metadata.R') # remove white space from station names

df_meta_region3 <- clean_metadata(df_meta_region3) # remove white space from station names


ADC_POST_Detided_region3 <- clean_timeseries(timeseries = ADC_POST_Detided_region3, 
                                             metadata = df_meta_region3 
                                                            %>% filter(stationname != 'Lewisetta')
                                             ) %>%
                                select(1:13, 15:14, 16:30)

NOAA_OBS_Detided_region3 <- clean_timeseries(timeseries = NOAA_OBS_Detided_region3, metadata = df_meta_region3) %>%
                              select(-Lewisetta) %>% # exclude Lewisetta for consistency with ADCIRC data
                              select(c(1:3, 30:4)) # re-arrange stations to match order of columns in ADC_POST_Detided_region3

df_meta_region3 <- df_meta_region3 %>% 
                          filter(stationname != 'Lewisetta') # remove Lewisetta from meta data
```

```{r compute yearly maxima for each station, warning = F}
# create data frame with yearly maxima over hourly observations for each station
# df_max_ADCIRC <- ADC_POST_Detided_region3 %>%
           #  select(-TIME, -month, -day) %>%
           # group_by(year) %>%
          # summarise_all(max, na.rm = T) %>%
          # mutate(year = as.numeric(year))

# create data frame with yearly maxima over hourly observations for each station
#df_max_NOAA <- NOAA_OBS_Detided_region3 %>%
                # select(-TIME, -month, -day) %>%
                # group_by(year) %>%
                # summarise_all(max, na.rm = T) %>%
                # mutate(year = as.numeric(year)) %>%
                # replace_with_na_all(~.x == -Inf)
                

# compute data frame with daily mean for each station
df_mean_ADCIRC <- ADC_POST_Detided_region3 %>%
  group_by(year, month, day) %>%
  summarise_all(mean, na.rm = T)

df_mean_NOAA <- NOAA_OBS_Detided_region3 %>%
  group_by(year, month, day) %>%
  summarise_all(mean, na.rm = T)

# create data frame with yearly maxima over daily means for each station
df_max_ADCIRC <- df_mean_ADCIRC[, -(2:4)] %>%
  group_by(year) %>%
  summarise_all(max, na.rm = T) %>%
  mutate(year = as.numeric(year))
 
df_max_NOAA <- df_mean_NOAA[, -(2:4)] %>%
                  group_by(year) %>%
                  summarise_all(max, na.rm = T) %>%
                  mutate(year = as.numeric(year)) %>%
                  replace_with_na_all(~.x == -Inf)
```

```{r 1st stage of inference: station-by-station non-stationary GEV fit}
gev_results <- function(df_max) {
  
  gev_results <- list() # list to store independent GEV fits for each station

  # fit and store the models in the prepared list
  for(i in 2:ncol(df_max)) {
    gev_results[[i-1]] <- fevd(na.omit(df_max[[i]]), use.phi = T, type = 'GEV') # phi = T means log(sigma) used instead of sigma
  }

  names(gev_results) <- colnames(df_max)[-1] # add station names to results
  
  return(gev_results)
  
}

# which stations have more than 10 missing years?
bad_stations <- which(apply(df_max_NOAA[, -1], 2, function(x) sum(is.na(x))) > 10) + 1

gev_results_ADCIRC <- gev_results(df_max_ADCIRC)
gev_results_NOAA <- gev_results(df_max_NOAA[, -bad_stations]) # exclude bad years


par_results <- function(gev_results) {
  
  # compute and store the GEV parameter MLEs
  par_results <- list()

  for(i in 1:length(gev_results)) {
  
    par_results[[i]] <- gev_results[[i]]$results$par
  
  }

  names(par_results) <- names(gev_results) # add station names to results

  return(par_results)

}

par_results_ADCIRC <- par_results(gev_results_ADCIRC)
par_results_NOAA <- par_results(gev_results_NOAA)

cov_results <- function(gev_results) {

  # compute and store the estimated co-variance matrices
  cov_results <- list()

    for(i in 1:length(gev_results)) {
   
      cov_results[[i]] <- solve(gev_results[[i]]$results$hessian)
  
    }

    names(cov_results) <- names(gev_results) # add station names to results
  
    return(cov_results)

}

cov_results_ADCIRC <- cov_results(gev_results_ADCIRC)
cov_results_NOAA <- cov_results(gev_results_NOAA)
```

```{r collect 1st stage inference output into flextable}
# ADCIRC
stage1_ADCIRC_par <- Reduce(rbind, par_results_ADCIRC)
stage1_ADCIRC_par <- stage1_ADCIRC_par %>% as.data.frame() %>% round(2)

station <- names(par_results_ADCIRC)
stage1_ADCIRC_par <- cbind(station, stage1_ADCIRC_par)
stage1_ADCIRC_par_a <- stage1_ADCIRC_par[1:13, ]
stage1_ADCIRC_par_b <- stage1_ADCIRC_par[14:26, ]

stage1_ADCIRC_par_a <- stage1_ADCIRC_par_a %>% flextable()
stage1_ADCIRC_par_b <- stage1_ADCIRC_par_b %>% flextable()

stage1_ADCIRC_par_a <- stage1_ADCIRC_par_a %>% hline()
stage1_ADCIRC_par_b <- stage1_ADCIRC_par_b %>% hline()
                                                                      
stage1_ADCIRC_par_a <- stage1_ADCIRC_par_a %>% add_header_row(top = TRUE, values = c('GEV Parameter Estimate at Each Station (ADCIRC)', rep('', 3))) %>%  merge_at(i = 1, j = 1:4, part = "header") %>% bold(i = 1, bold = TRUE, part = "header") %>% italic(i = 2, part = 'header') %>% fontsize(i = 1, size = 10, part = "header")

stage1_ADCIRC_par_b <- stage1_ADCIRC_par_b %>% add_header_row(top = TRUE, values = c('GEV Parameter Estimates at Each Station (ADCIRC)', rep('', 3))) %>%  merge_at(i = 1, j = 1:4, part = "header") %>% bold(i = 1, bold = TRUE, part = "header") %>% italic(i = 2, part = 'header') %>% fontsize(i = 1, size = 10, part = "header")
  
stage1_ADCIRC_par_a
stage1_ADCIRC_par_b

# NOAA                                  
stage1_NOAA_par <- Reduce(rbind, par_results_NOAA)
stage1_NOAA_par <- stage1_NOAA_par %>% as.data.frame() %>% round(3)

station <- names(par_results_NOAA)
stage1_NOAA_par <- cbind(station, stage1_NOAA_par)

stage1_NOAA_par <- stage1_NOAA_par %>% flextable()

stage1_NOAA_par
stage1_NOAA_par <- stage1_NOAA_par %>% hline()

stage1_NOAA_par <- stage1_NOAA_par %>% add_header_row(top = TRUE, values = c('GEV Parameter Estimates at Each Station (NOAA)', rep('', 3))) %>% merge_at(i = 1, j = 1:4, part = "header") %>% bold(i = 1, bold = TRUE, part = "header") %>% italic(i = 2, part = 'header') %>% fontsize(i = 1, size = 10, part = 'header')

stage1_NOAA_par
```

```{r specify model hyper parameters: L, d, and p}
L_ADCIRC <- length(gev_results_ADCIRC) # number of spatial locations used in ADCIRC model
L_NOAA <- length(gev_results_NOAA) # number of spatial locations used in NOAA model

d <- 3 # dimension of spatial process

# total number of parameters in model to be estimated
p <- 2*d + d*(d + 1)/2 # first term includes the mean and range parameters, second term the co-regionalization parameters

# examine growth of parameter space dimension as the dimension of the spatial process increases
p_function <- function(x) 2*x + x*(x + 1)/2

tibble(x = 1:20, y = p_function(x)) %>% 
  ggplot(aes(x = x, y = y)) +
  geom_line(size = 0.3, col = 'blue') +
  labs(x = 'Dimension of Gaussian process', y = '# of parameters') +
  scale_y_continuous(breaks = seq(0, 250, by = 25)) 
```

```{r compute data vector: theta_hat}
theta_hat <- function(par_results, L) {
  
  # compute data vector of MLEs for gev parameters
  theta_hat <- vector()

  # order one location after the other
    for(i in 1:L) { # each location

    theta_hat <- c(theta_hat, par_results[[i]])

    }
  
  return(theta_hat)

}

theta_hat_ADCIRC <- theta_hat(par_results_ADCIRC, L_ADCIRC)
theta_hat_NOAA <- theta_hat(par_results_NOAA, L_NOAA)
```

```{r compute distance matrix: dist_matrix}
units <- 10^3 # what should you convert the m to? 1000 would translate m to km

dist_matrix_ADCIRC <- df_meta_region3 %>%
  select(lon, lat) %>%
  slice(26:1) %>% # re-arrange stations to match order of parameters fit by fevd
  distm(fun = distHaversine)/units # great-circle-distance via haversine method, assumes spherical earth; units of 10,000 meters

dist_matrix_NOAA <- df_meta_region3 %>%
  slice(26:1) %>% 
  slice(-(bad_stations - 1)) %>% # re-arrange stations to match order of parameters fit by fevd
  select(lon, lat) %>%
  distm(fun = distHaversine)/units # great-circle-distance via haversine method, assumes spherical earth

rownames(dist_matrix_ADCIRC) <- colnames(df_max_ADCIRC[, -1])
colnames(dist_matrix_ADCIRC) <- colnames(df_max_ADCIRC[, -1])

rownames(dist_matrix_NOAA) <- colnames(df_max_NOAA[, -c(1, bad_stations)])
colnames(dist_matrix_NOAA) <- colnames(df_max_NOAA[, -c(1, bad_stations)])
```

```{r compute variance matrix for measurement error process: W, warning = F}
# block-diagonal approach (assuming station-by-station independence)
W <- function(cov_results) {
  
  result <- bdiag(cov_results) %>% as.matrix()
  
  return(result)
  
}

set.seed(2)
# non-parametric bootstrap approach
gamma <- function(df_max, B, N, L) {
  
  gamma <- list() # each row is a bootstrap iteration with the order of the vector station by station, see Russell et al (2019)

  for(j in 1:B) { # for each bootstrap iteration
  
    index_sample <- sample(1:N, replace = T) # sample indices with replacement
    boot_max <- df_max[index_sample, ] # use those to sample years

    boot_model <- list() # list to store independent GEV fits for each station

    # fit and store the models in the prepared list
    for(i in 2:ncol(df_max)) {
      boot_model[[i-1]] <- fevd(na.omit(boot_max[[i]]), 
                                use.phi = T, 
                                type = 'GEV') # phi = T means log(sigma) used instead of sigma  
    }

    names(boot_model) <- colnames(boot_max)[-1] # add station names to results

    # compute and store the GEV parameter MLEs
    boot_par <- list()

    for(i in 1:length(boot_model)) {
  
      boot_par[[i]] <- boot_model[[i]]$results$par
  
    }

    names(boot_par) <- colnames(boot_max)[-1]

    # combine the parameter estimates in a vector in a station-by-station order
    storage <- vector()
      for(i in 1:L) {
        storage <- c(storage, boot_par[[i]])
      }
  
    # add them to the list
    gamma[[j]] <- storage

  }

  gamma <- Reduce(rbind, gamma)
  rownames(gamma) <- 1:nrow(gamma)
  
  return(gamma)

}

gamma_ADCIRC <- gamma(df_max_ADCIRC, 
                      1000, 
                      nrow(df_max_ADCIRC), 
                      L_ADCIRC)

gamma_NOAA <- gamma(df_max_NOAA[, -bad_stations], 
                    1000, 
                    nrow(df_max_NOAA), 
                    L_NOAA)


W_boot <- function(gamma, L) {
  
  # non-parametric bootstrap estimate of the error covariance matrix
  W_boot <- matrix(rep(0, d*L), nrow = d*L, ncol = d*L) # entry (i, j) of W is the covariance of rows i, j of gamma

  for(i in 1:(d*L)) {
  
    for(j in 1:(d*L)) {
    
      W_boot[i, j] <- cov(gamma[, i], gamma[, j])
    
    }
  
  }
  
  return(W_boot)

}

# Wendland 2 covariance function; used in computation of tapering matrix
wendland2 <- function(d, lambda) {
  
  if(d <= lambda) {
    
    result <- ((1 - d/lambda)^6) * ((35/3)*(d/lambda)^2 + 6*(d/lambda) + 1)
    
  } else {
    
    result <- 0
    
  }
  
  return(result)
  
}

# compute tapering matrix based off of Wendland2 covariance function; ordered station by station
tap <- function(dist_matrix, lambda, L) {

  C_W2 <- matrix(rep(0, L*L), nrow = L, ncol = L)

  for(i in 1:L){
  
    for(j in 1:L) {
    
      C_W2[i, j] <- wendland2(dist_matrix[i, j], lambda)
    
    }
  
  }
  
  tap <- kronecker(C_W2, rep(1, d) %*% t(rep(1, d)))
  
  return(tap)

}

W_boot_ADCIRC <- W_boot(gamma_ADCIRC, L_ADCIRC)
W_boot_NOAA <- W_boot(gamma_NOAA, L_NOAA)

lambda <- 700 # the regularization parmaeter in the Wendland2 function. Units of km. Covariance set to 0 if dist between locations are exceeded

tap_ADCIRC <- tap(dist_matrix_ADCIRC, lambda, L_ADCIRC) # 700 km
tap_NOAA <- tap(dist_matrix_NOAA, lambda, L_NOAA) # 700 km

# compute tapered non-parametric bootstrap estimate of error covariance matrix
W_tap <- function(W_boot, tap) {
  
  W_tap <- hadamard.prod(W_boot, tap)
  
  return(W_tap)

}

W_tap_ADCIRC <- W_tap(W_boot_ADCIRC, tap_ADCIRC)
W_tap_NOAA <- W_tap(W_boot_NOAA, tap_NOAA)
```

```{r heatmaps for W estimate}
# heatmaps for regularized non-parameter estimates of W, the measurement error covariance matrix

pheatmap(W_tap_ADCIRC, cluster_rows = FALSE, cluster_cols = FALSE, main = 'Regularized Non-Parameteric Bootstrap Estimate for W (ADCIRC)') # ADCIRC
pheatmap(W_tap_NOAA, cluster_rows = FALSE, cluster_cols = FALSE, main = 'Regularized Non-Parameteric Bootstrap Estimate for W (NOAA)') # NOAA
```

```{r compute variance matrix for spatially correlated random effects: S}
S <- function(A, rho, dist, L) {
  
  V <- list()
  
  for(i in 1:L) {
    
    storage <- list()
    
    for(j in 1:L) {
      
      S <- diag(d)
      
      for(k in 1:d) {
        
        S[k, k] <- exp(-dist[i, j]/rho[k])
        
      }
      
     C <- A %*% S %*% t(A)
     
     storage[[j]] <- C
      
    }
    
    row_cov <- Reduce(cbind, storage)
    
    V[[i]] <- row_cov
    
  }
  
  result <- Reduce(rbind, V)
  
  return(result)
  
}
```


```{r compute Gaussian process likelihood}
# par = parameters, W = error covariance, dist = station by station distances
gaussian_process_likelihood <- function(par, data,  W, dist, L) {

#  co-regionalization matrix used to define S below 
  A <- matrix(0, nrow = d, ncol = d)
  A[upper.tri(A, diag = TRUE)] <- par[(d + 1):(p - d)]
  A <- t(A)

  # variance matrix for spatially correlated random effects
  S <- S(A, par[(p - d + 1):p], dist, L)

  # mean vector  of the MVN density
  mu <- rep(par[1:d], L)

  # variance matrix of the MVN density
  V <- S + W 
  
  # MVVN negative log-likelihood
  log_lik <- -(L*d/2)*log(2*pi) - (1/2)*log(det(V)) - (1/2)*t(data - mu) %*% solve(V) %*% (data - mu)
  result <- -log_lik

  # alternatively, use MVN density from mvtnorm package
  # result <- -dmvnorm(data, mean = mu, sigma = S + W, log = T)
  
  return(result)

}
```

```{r 2nd stage of inference: given theta_hat and W; find beta, A and rho}
gaussian_results <- function(theta_hat, W_tap, dist_matrix, L_data, seed) {
  
  start_time <- Sys.time() # track run time of optim

  set.seed(seed)

  # fit p dimensional Gaussian process with assumed form of W
  gaussian_process_fit <-  optim(c(runif(p - d, 0.1, 100), runif(d, 50, max(dist_matrix))), 
                               gaussian_process_likelihood, 
                               data = theta_hat,
                               W = W_tap, 
                               dist = dist_matrix, 
                               L = L_data,
                               method = 'BFGS', 
                               hessian = T, 
                               control=list(maxit = 10000))

  end_time <- Sys.time()
  run_time <- end_time-start_time

  run_time

  # extract the mean parameter values over R^2
  beta <- gaussian_process_fit$par[1:d]

  # extract A, the co-regionalization  lower diagonal matrix
  A <- matrix(0, nrow = d, ncol = d)
  A[upper.tri(A, diag = TRUE)] <- gaussian_process_fit$par[(d + 1):(p - d)]
  A <- t(A)

  # extract range parameters
  rho <- gaussian_process_fit$par[(p - d + 1):p]

  # extract covariance matrix
  eigen_cov <- sort(eigen(solve(gaussian_process_fit$hessian))$values)

  # organize results
  gaussian_results <- list(beta, A, rho, eigen_cov)
  names(gaussian_results) <- c('beta: mean parameter values over R^2', 
                             'A: co-regionalization matrix', 
                             'rho: range parameters',
                             'eigenvalues of approximate covariance matrix')
  
  return(gaussian_results)
  
}

gaussian_results_ADCIRC <- gaussian_results(theta_hat_ADCIRC, W_tap_ADCIRC, dist_matrix_ADCIRC, L_ADCIRC, 5)
gaussian_results_NOAA <- gaussian_results(theta_hat_NOAA, W_tap_NOAA, dist_matrix_NOAA, L_NOAA, 5)
```

```{r}
pheatmap(S(gaussian_results_ADCIRC$`A: co-regionalization matrix`, gaussian_results_ADCIRC$`rho: range parameters`, dist_matrix_ADCIRC, L_ADCIRC) + W_tap_ADCIRC, cluster_rows = FALSE, cluster_cols = FALSE, main = 'Estimated Covariance Matrix of Multidimensional Gaussian Process (ADCIRC)')

pheatmap(S(gaussian_results_NOAA$`A: co-regionalization matrix`, gaussian_results_NOAA$`rho: range parameters`, dist_matrix_NOAA, L_NOAA) + W_tap_NOAA, cluster_rows = FALSE, cluster_cols = FALSE, main = 'Estimated Covariance Matrix of Multidimensional Gaussian Process (NOAA)')
```

```{r collect 2st stage inference output into kable}
gaussian_results_ADCIRC 
gaussian_results_NOAA

stage2_par_ADCIRC <- cbind(data.frame(gaussian_results_ADCIRC$`beta: mean parameter values over R^2`,
                                gaussian_results_ADCIRC$`rho: range parameters`), 
                           gaussian_results_ADCIRC$`A: co-regionalization matrix`) %>% round(2)


stage2_par_ADCIRC %>% kable(col.names = NULL, 
                            caption = "Gaussian Process Parameter Estimates (ADCIRC)", 
                            ) %>% 
               kable_classic() %>%
               kable_paper("hover", full_width = F)  %>% 
               add_header_above(c("$\\hat\\beta$" = 1, "$\\hat\\rho$" = 1, "$\\hat A$" = 3))


stage2_par_NOAA <- cbind(data.frame(gaussian_results_NOAA$`beta: mean parameter values over R^2`,
                                gaussian_results_NOAA$`rho: range parameters`), 
                           gaussian_results_NOAA$`A: co-regionalization matrix`) %>% round(2)


stage2_par_NOAA %>% kable(col.names = NULL, caption = "Gaussian Process Parameter Estimates (NOAA)") %>% 
               kable_classic() %>%
               kable_paper("hover", full_width = F)  %>% 
               add_header_above(c("$\\hat\\beta$" = 1, "$\\hat\\rho$" = 1, "$\\hat A$" = 3))

```

```{r}
stage2_par_ADCIRC <- cbind(data.frame(beta = gaussian_results_ADCIRC$`beta: mean parameter values over R^2`,
                                rho = gaussian_results_ADCIRC$`rho: range parameters`), 
                           gaussian_results_ADCIRC$`A: co-regionalization matrix`) %>% round(2)

colnames(stage2_par_ADCIRC) <- c('beta', 'rho', 'A1', 'A2', 'A3')

stage2_par_ADCIRC %>% flextable() %>%
                      add_header_row(top = T, 
                                     values = c('Gaussian Process Parameter Estimates (ADCIRC)', '', '', '', '')) %>%
                      set_header_labels(beta = 'beta',
                                        rho = 'rho',
                                        A1 = '',
                                        A2 = 'A',
                                        A3 = '') %>%
                      bold(i = 1, bold = T, part = 'header') %>%
                      merge_at(i = 1, j = 1:5, part = 'header') %>%
                      fontsize(i = 1, j = 1, size = 9, part = 'header')  %>%
                      vline(j = 1:2, part = 'body')

stage2_par_NOAA <- cbind(data.frame(beta = gaussian_results_NOAA$`beta: mean parameter values over R^2`,
                                rho = gaussian_results_NOAA$`rho: range parameters`), 
                           gaussian_results_NOAA$`A: co-regionalization matrix`) %>% round(2)

colnames(stage2_par_NOAA) <- c('beta', 'rho', 'A1', 'A2', 'A3')

stage2_par_NOAA %>% flextable() %>%
                      add_header_row(top = T, 
                                     values = c('Gaussian Process Parameter Estimates (NOAA)', '', '', '', '')) %>%
                      set_header_labels(beta = 'beta',
                                        rho = 'rho',
                                        A1 = '',
                                        A2 = 'A',
                                        A3 = '') %>%
                      bold(i = 1, bold = T, part = 'header') %>%
                      merge_at(i = 1, j = 1:5, part = 'header') %>%
                      fontsize(i = 1, j = 1, size = 9, part = 'header') %>%
                      vline(j = 1:2, part = 'body')
```



```{r implement kriging}
# theta_hat is output from 1st stage of inference, par is output from second stage, W is error process covariance
kriging_pred <- function(new_loc, known_loc, gaussian_results, theta_hat, dist_matrix, W, L) {
  
  beta_hat <- gaussian_results$`beta: mean parameter values over R^2`
  rho <- gaussian_results$`rho: range parameters`
  A <- gaussian_results$`A: co-regionalization matrix`

  V <- S(A, rho, dist_matrix, L)
  sigma_inv <- solve(V + W) # plug-in MLE estimate of covariance matrix for theta hat
  
  tau <- matrix(rep(0, d*L), nrow = d, ncol = d*L) # compute covariance of new location and theta hat
  
  storage <- list()
  
   for(i in 1:L) { # for each location
     
     C <- diag(d) # covariance matrix for new obs and location i
     
     for(j in 1:d) { # for each spatial process
       
       C[j, j] <- exp(-distHaversine(new_loc, known_loc[i, ])*(units^-1)/rho[j])
       
     }
     
     storage[[i]] <-  A %*% C %*% t(A)
     
   }
  
  tau <- Reduce(cbind, storage) # covariance matrix of new location with existence locations
  
  pred <- beta_hat + tau %*% sigma_inv %*% (theta_hat - rep(beta_hat, L))
  
  cov <- A %*% t(A) - tau %*% sigma_inv %*% t(tau)
    
  rownames(pred) <- c('location', 'log.scale', 'shape')
  
  result <- list(pred, cov)
  names(result) <- c('predictions', 'covariance')
  
  return(result)

}
```

```{r compute kriging predictions and covariances for known stations}
known_loc_ADCIRC <- df_meta_region3 %>% slice(26:1) %>% select(lon, lat)
known_loc_NOAA <- df_meta_region3 %>% slice(26:1) %>% slice(-(bad_stations - 1)) %>% select(lon, lat)

# ADCIRC
kriging_check_ADCIRC <- list()

for(i in 1:L_ADCIRC) {
  
kriging_check_ADCIRC[[i]] <- kriging_pred(known_loc_ADCIRC[i, ], 
                              known_loc_ADCIRC,
                              gaussian_results_ADCIRC,
                              theta_hat_ADCIRC, 
                              dist_matrix_ADCIRC,
                              W_tap_ADCIRC,
                              L_ADCIRC)

}
  
names(kriging_check_ADCIRC) <- colnames(df_max_ADCIRC[,-1])

for(i in 1:L_ADCIRC) {
  
  print(kriging_check_ADCIRC[i])
  print(par_results_ADCIRC[i])
  print(cov_results_ADCIRC[i])
  
}

# NOAA
kriging_check_NOAA <- list()

for(i in 1:L_ADCIRC) { # L_NOAA if only checking sites NOAA surface fit on
  
kriging_check_NOAA[[i]] <- kriging_pred(known_loc_ADCIRC[i, ], # known_loc_NOAA[i, ] if only  etc.
                              known_loc_NOAA,
                              gaussian_results_NOAA,
                              theta_hat_NOAA, 
                              dist_matrix_NOAA,
                              W_tap_NOAA,
                              L_NOAA)

}
  
names(kriging_check_NOAA) <- colnames(df_max_ADCIRC[,-1]) # colnames(df_max_NOAA[, -c(1, bad_stations)]) if only etc.

for(i in 1:L_NOAA) {
  
  print(kriging_check_NOAA[i])
  print(par_results_NOAA[i])
  print(cov_results_NOAA[i])
  
}
```

```{r implement return levels}
return_levels <- function(par, cov, p) {
  
  scale <- exp(par[2])
  
  y_p <- -log(1 - p) # 1/p return level, where p is the upper tail probability: see Coles (2001) page 56,
  
  if (abs(par[3]) > 0.001 ) { # if the shape parameter is not about zero
    
  z_p <- par[1] - (scale/par[3])*(1 - y_p^(-par[3]))
  
  } else { # if the she parameter is about zero
    
  z_p <- par[1] - scale*log(y_p)
    
  }
  
  # compute variance for z_p
  
    # compute gradient of z_p via delta-method approximation
    z_p_grad <- c(1, 
               -par[3]^(-1)*(1 - y_p^-par[3]), 
                scale*par[3]^(-2)*(1 - y_p^-par[3]) - scale*par[3]^(-1)*y_p^(-par[3])*log(y_p))
  
    z_p_var <- t(z_p_grad) %*% cov %*% z_p_grad

 result <- list(z_p, sqrt(z_p_var))
 names(result) <- c('1/p return level', 'sd')
 
 return(result)
  
}
```

```{r define coastline region to generate predictions over}
# generate longitude sequence
reps <- length(seq(0.00, 10, by = 0.2))

lon_storage <- vector()
for(i in seq(0.0, 10, by = 0.2)) {
  
  lon_storage <- c(lon_storage, seq(-82 + i, -75 + i, length.out = length(seq(30, 45, by = 0.1))))
  
}

# store lon-lat coordinates in tibble
coastline <- tibble(lon = lon_storage, 
                    lat = c(rep(seq(30, 45, by = 0.1), reps)
                            )
                    ) 
```


```{r compute kriging predictions and covariances over coastline}
coastline_kriging <- function(known_loc, gaussian_results, theta_hat, dist_matrix, W_tap, L) {
  
  coastline_storage <- list()

  for(i in 1:nrow(coastline)) {
  
    progress(i)
  
    coastline_storage[[i]] <- kriging_pred(coastline[i, ],
                                          known_loc,
                                          gaussian_results,
                                          theta_hat,
                                          dist_matrix,
                                          W_tap,
                                          L)
  
  }

  return(coastline_storage)
  
}

coastline_kriging_ADCIRC <- coastline_kriging(known_loc_ADCIRC, 
                                              gaussian_results_ADCIRC, 
                                              theta_hat_ADCIRC, 
                                              dist_matrix_ADCIRC, 
                                              W_tap_ADCIRC, 
                                              L_ADCIRC)

coastline_kriging_NOAA <- coastline_kriging(known_loc_NOAA, 
                                              gaussian_results_NOAA, 
                                              theta_hat_NOAA, 
                                              dist_matrix_NOAA, 
                                              W_tap_NOAA, 
                                              L_NOAA)
```

```{r compute return levels and variances for coastline}
v1 <- vector() # storage for 1/p return levels
v2 <- vector() # storage for corresponding sd

p <- 1/100

for(i in 1:nrow(coastline)) {
v1[i] <- return_levels(coastline_kriging_ADCIRC[[i]][[1]], coastline_kriging_ADCIRC[[i]][[2]], p)$'1/p return level'
v2[i] <- return_levels(coastline_kriging_ADCIRC[[i]][[1]], coastline_kriging_ADCIRC[[i]][[2]], p)$'sd'
}

w1 <- vector() # storage for 1/p return levels
w2 <- vector() # storage for corresponding sd

for(i in 1:nrow(coastline)) {
w1[i] <- return_levels(coastline_kriging_NOAA[[i]][[1]], coastline_kriging_NOAA[[i]][[2]], p)$'1/p return level'
w2[i] <- return_levels(coastline_kriging_NOAA[[i]][[1]], coastline_kriging_NOAA[[i]][[2]], p)$'sd'
}

return_level_results_ADCIRC <- tibble(return_levels = v1, 
                                      sd = v2, 
                                      lower95 = v1 - qnorm(.975)*v2, 
                                      upper95 = v1 + qnorm(.975)*v2, 
                                      lon = coastline$lon, 
                                      lat = coastline$lat)

return_level_results_NOAA <- tibble(return_levels = w1, 
                                      sd = w2, 
                                      lower95 = w1 - qnorm(.975)*w2, 
                                      upper95 = w1 + qnorm(.975)*w2, 
                                      lon = coastline$lon, 
                                      lat = coastline$lat)

write_csv(return_level_results_ADCIRC, './data/return_level_results_ADCIRC.csv')
write_csv(return_level_results_NOAA, './data/return_level_results_NOAA.csv')
```

```{r compute return levels and variances for known stations}
x1 <- vector()
x2 <- vector()

for(i in 1:length(kriging_check_ADCIRC)) {
  x1[i] <- return_levels(kriging_check_ADCIRC[[i]][[1]], kriging_check_ADCIRC[[i]][[2]], p)$'1/p return level'
  x2[i] <- return_levels(kriging_check_ADCIRC[[i]][[1]], kriging_check_ADCIRC[[i]][[2]], p)$'sd'
}

return_level_results_ADCIRC_check <- tibble(return_levels = x1,
                                            sd = x2,
                                            lower95 = x1 - qnorm(.975)*x2,
                                            upper95 = x1 + qnorm(.975)*x2,
                                            lon = known_loc_ADCIRC$lon,
                                            lat = known_loc_ADCIRC$lat,
                                            stationname = df_meta_region3[26:1, 2])

y1 <- vector()
y2 <- vector()

for(i in 1:length(kriging_check_NOAA)) {
  y1[i] <- return_levels(kriging_check_NOAA[[i]][[1]], kriging_check_NOAA[[i]][[2]], p)$'1/p return level'
  y2[i] <- return_levels(kriging_check_NOAA[[i]][[1]], kriging_check_NOAA[[i]][[2]], p)$'sd'
}

NOAA_names <- df_meta_region3 %>%
                slice(26:1) %>%
                slice(-(bad_stations -1)) # recall index weirdness
            
return_level_results_NOAA_check <- tibble(return_levels = y1,
                                            sd = y2,
                                            lower95 = y1 - qnorm(.975)*y2,
                                            upper95 = y1 + qnorm(.975)*y2,
                                            lon = known_loc_ADCIRC$lon, #  known_loc_NOAA$lon if only using stations NOAA surface fit with
                                            lat = known_loc_ADCIRC$lat, # known_loc_NOAA$lat if etc.
                                            stationname = df_meta_region3[26:1, 2]) # NOAA_names$stationname if etc.
```

```{r produce return level plots, warning = F}
# 3D plot (ADCIRC). colorscale options: Greys, YlGnBu, Greens, YlOrRd, Bluered, RdBu, Reds, Blues, Picnic, Rainbow, Portland, Jet, Hot, Blackbody, Earth, Electric, Viridis, Cividis

fig1 <- plot_ly(return_level_results_ADCIRC, # add return level surface
        x = ~lon, 
        y = ~lat, 
        z = ~return_levels,
        marker = list(size = 0.5, 
                      color = ~sd,
                      colorscale = 'Portland', 
                      showscale = F, 
                      colorbar = list(len = 0.5, 
                                      itle = list(text = 'Standard Deviation (m)')) 
                      ),
        legendgrouptitle = list(text = 'Data'),
        mode = 'markers', 
        type = 'scatter3d',
        name = '100-Year Return Level Surface (ADCIRC)',
        scene = 'scene1'
        ) %>% 
      add_trace(data = return_level_results_ADCIRC_check, # add stations used to generate surface
                x = ~lon,
                y = ~lat,
                z = ~return_levels,
                marker = list(color = 'black', 
                              size = 1,
                              showscale = F),
                mode = 'markers',
                type = 'scatter3d',
                text = ~stationname,
                textposition = 'middle right',
                textfont = list(color = 'black', size = 10),
                name = 'Observation Stations (ADCIRC)') %>%
      add_trace(data = return_level_results_ADCIRC, # add upper 95% CI
            x = ~lon, 
            y = ~lat, 
            z = ~upper95,
            mode = "markers", 
            type = "scatter3d", 
            marker = list(size = 0.5, 
                          color = 'lightskyblue', 
                          symbol = 104,
                          showscale = F),
            name = 'Upper 95% CI (ADCIRC)') %>%
     add_trace(data = return_level_results_ADCIRC, # add lower 95% CI
            x = ~lon, 
            y = ~lat, 
            z = ~lower95,
            mode = "markers", 
            type = "scatter3d", 
            marker = list(size = 0.5, 
                          color = "lightskyblue", 
                          symbol = 104,
                          showscale = F),
            name = 'Lower 95% CI (ADCIRC)'
            ) %>%
      layout(title = '100-Year Return Level Surface (ADCIRC) for Daily-Mean Sea-Level over the U.S. East Coast',
             scene = list(xaxis = list(title = 'Longitude'), 
                          yaxis = list(title = 'Latitude'), 
                          zaxis = list(title = '100-Year Return Level (m)')),
             showlegend = F
           )

# 3D plot (NOAA)
fig2 <- plot_ly(return_level_results_NOAA, # add return level surface
        x = ~lon, 
        y = ~lat, 
        z = ~return_levels,
        marker = list(size = 0.5, 
                      color = ~sd,
                      colorscale = 'Portland', 
                      showscale = T, 
                      colorbar = list(len = 0.5, 
                                       title = list(text = 'Standard Deviation (m)')) 
                      ),
        legendgrouptitle = list(text = 'Data'),
        mode = 'markers', 
        type = 'scatter3d',
        name = '100-Year Return Level Surface (NOAA)',
        scene = 'scene2',
        showlegend = T
        ) %>% 
      add_trace(data = return_level_results_NOAA_check, # add stations used to generate surface
                x = ~lon,
                y = ~lat,
                z = ~return_levels,
                marker = list(color = 'black', 
                              size = 1,
                              showscale = F),
                mode = 'markers',
                type = 'scatter3d',
                text = ~stationname,
                textposition = 'middle right',
                textfont = list(color = 'black', size = 10),
                name = 'Observation Stations (NOAA)') %>%
      add_trace(data = return_level_results_NOAA,  # add 95% upper CI
            x = ~lon, 
            y = ~lat, 
            z = ~upper95,
            mode = "markers", 
            type = "scatter3d", 
            marker = list(size = 0.5, 
                          color = 'lightskyblue', 
                          symbol = 104,
                          showscale = F),
            name = 'Upper 95% CI (NOAA)') %>%
     add_trace(data = return_level_results_NOAA, # add 95% lower CI
            x = ~lon, 
            y = ~lat, 
            z = ~lower95,
            mode = "markers", 
            type = "scatter3d", 
            marker = list(size = 0.5, 
                          color = "lightskyblue", 
                          symbol = 104,
                          showscale = F),
            name = 'Lower 95% CI (NOAA)'
            ) %>%
      layout(title = '100-Year Return Level Surface (NOAA) for Daily-Mean Sea-Level over the U.S. East Coast',
             scene = list(xaxis = list(title = 'Longitude'), 
                          yaxis = list(title = 'Latitude'), 
                          zaxis = list(title = '100-Year Return Level (m)'))
           )

fig1
fig2

fig3 <- subplot(fig1, fig2) %>%  layout(title = '100-Year Return Level Surface for Yearly (Detided Daily Mean) Sea-Level Maxima over the U.S. East Coast',
                                scene = list(domain=list(x=c(-3,-2),y=c(0,1))),
                                scene2 = list(domain=list(x=c(3,4),y=c(0,1)), 
                                              xaxis = list(title = 'Longitude'), 
                                              yaxis = list(title = 'Latitude'),
                                              zaxis = list(title = '100-Year Return Level (m)')),
                                annotations = list(list(x = 0.25,  
                                                        y = .9,  
                                                        text = "ADCIRC",  
                                                        xref = "paper",  
                                                        yref = "paper",  
                                                        xanchor = "center",  
                                                        yanchor = "bottom",  
                                                        showarrow = FALSE 
                                                        ),
                                                   list(x = .8,  
                                                        y = .9,  
                                                        text = "NOAA",  
                                                        xref = "paper",  
                                                        yref = "paper",  
                                                        xanchor = "center",  
                                                        yanchor = "bottom",  
                                                        showarrow = FALSE 
                                                        )
                                                    )
                                            )

fig3
```
